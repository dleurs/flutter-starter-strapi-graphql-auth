import 'package:artemis/artemis.dart';
import 'package:frontend/src/helpers/log.dart';
import 'package:gql_exec/gql_exec.dart';
import 'package:gql_link/gql_link.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:frontend/src/api/base/request_errors.dart';

typedef SuccessfulRequest<D> = void Function(D data);

typedef OnErrorRequest<E> = void Function(List<E> errors);

///
/// Abstract class to manage graphQL requests
/// where [T] is the final object the request has to return
/// and [D] is the query object defined in the .graphql file and generated by gql
///
abstract class GraphQLRequest<T, D> {
  final ArtemisClient client;

  GraphQLRequest(this.client);

  GraphQLQuery<D, JsonSerializable> buildQuery();

  T buildResponse(D data);

  Future<T> call() async {
    final query = buildQuery();
    //final Trace metric = FirebasePerformance.instance.newTrace("GraphQLRequest/${Config.flavorName}/${query.operationName}");
    //await metric.start();
    GraphQLResponse<D> response;
    try {
      Log.debug("Execute GraphQLRequest/${query.operationName}");
      response = await this.client.execute(buildQuery());
      /*if (response.hasErrors || response.data == null) {
        await metric.incrementMetric("failure", 1);
      } else {
        await metric.incrementMetric("success", 1);
      }*/
    } catch (e, stack) {
      if (e is LinkException) {
        Log.error("A server link error occurred performing ${this.runtimeType}",
            error: e.originalException, stackTrace: stack);
        //await Crashlytics.instance
        //    .recordError(e.originalException, stack, context: this.runtimeType);
        throw RequestException(errors: [
          RequestError(
              message:
                  "Link error performing ${this.runtimeType}: ${e.originalException}")
        ]);
      } else {
        Log.error("An error occurred performing ${this.runtimeType}",
            error: e, stackTrace: stack);
        //await Crashlytics.instance
        //   .recordError(e, stack, context: this.runtimeType);
        throw RequestException(errors: [
          RequestError(message: "Error performing ${this.runtimeType}: ${e}")
        ]);
      }
      // Record a Crashlytics error and throw an exception

    } finally {
      client.dispose();
      //await metric.stop();
    }

    RequestException exception;
    if (response.hasErrors) {
      exception = this.processErrors(_convertErrors(response.errors));
    } else if (!(response.data is D)) {
      exception = RequestException(errors: [
        RequestError(
            message:
                "Response data was not the right type. Expected ${D} got ${response.data.runtimeType}")
      ]);
    }

    if (exception != null) {
      // Records a Crashlytics error and throws the exception
      //await Crashlytics.instance.recordError(exception, StackTrace.current,
      //    context: this.runtimeType);
      throw exception;
    }
    return buildResponse(response.data);
  }

  List<RequestError> _convertErrors(List<GraphQLError> errors) {
    List<RequestError> result = List();
    for (var error in errors) {
      result.add(
          RequestError(message: error.message, extensions: error.extensions));
    }
    return result;
  }

  RequestException processErrors(List<RequestError> errors) {
    return RequestException(errors: errors);
  }
}
